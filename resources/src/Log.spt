my FD $*LOG = $*ERR;
constant $*log-level = 4;
constant $*log = False;
constant $*log-default-path = '👻';
constant @*log-symbols = <☠     ❗    ⚠    ℹ   ❔>;
constant @*log-levels  = <fatal error warn info debug>;
constant $*log-date-format = '%b %d %T';

class Log {
    method date~ {
        $self.${ cut '-d|' '-f1' }
    }
    method level~ {
        $self.${ cut '-d|' '-f2' }
    }
    method path~ {
        $self.${ cut '-d|' '-f3' }
    }
    method message~ {
        $self.${ cut '-d|' '-f4-' }
    }
}

# While logging is a WIP we'll just leave this here
augment Str {

    method log(Int $level, $path?) {
        if $*log {
            my $_path = $path || $*log-default-path;
            if $*log-level >= $level {
                on {
                    BusyBox {
                        $self.${
                            awk > $*LOG
                            -v "level_sym={@*log-symbols[$level]}"
                            -v "level=$level"
                            -v "path=$_path"
                            -v "pid=$?PID"
                            -v "date_format=$*log-date-format"
                            Q⟪
                                length() == 0 { next }
                                {
                                    if ($0 ~ /^([^|]+\|){3}/) {
                                        print gensub(/^(([^|]+\|){2})([^|]+\|)/, "\\1"path"/\\3",1)
                                    } else {
                                        "date '+"date_format"'" | getline date;
                                        printf "%s|%s|%s|%s\n",date,level_sym,path,$0;
                                    }
                                    if(level == 0)
                                        die = 1
                                }
                                END { if(die){ system("kill "pid) } }⟫
                        }
                    }
                    GNU {
                        $self.${
                            sed -ru > $*LOG
                            -e (
                                # if it looks like a log append its path to this one
                                # print and then branch to the end
                                ‘s§^(([^|]+\|){2})([^|]+\|)§\1’ ~ $_path ~ ‘/\3§;t;’ ~
                                # remove empty lines
                                '/^$/d;' ~
                                # Put the path on the front of the message
                                "s§^§$_path|§;" ~
                                # Put everything in hold space and put the date in pattern space
                                “h;s/.*/date '+$*log-date-format'/e;” ~
                                # Append the hold space to the date and add the
                                # insert the log level symbol between the two
                                ‘G;s§\n§|’ ~ @*log-symbols[$level] ~ ‘|§;’ ~
                                # Add a newline if it doesn't exist
                                ("\$e kill $?PID" if $level == 0)
                            )
                            -e '$a\\'
                        }
                    }
                }
            }
        }
    }
}

sub fatal($msg, $path?){
    $*log ?? $msg.log(0, $path) !! die $msg;
}
sub error($msg, $path?){ $*log ?? $msg.log(1, $path) !! note $msg }
sub warn ($msg, $path?){ $*log ?? $msg.log(2, $path) !! note $msg }
sub info ($msg, $path?){ $*log ?? $msg.log(3, $path) !! say $msg }
sub debug($msg, $path?){ $msg.log(4, $path) }

sub log-fifo(Int $level, $path?) --> File {
    my $log-fifo = File.tmp-fifo;
    # We don't really want to have to .cleanup. But if we don't and we
    # do a fatal log then the parent process will terminate and
    # therefore never reap this process. I wonder if there's a better
    # way to do it...
    (start {
        ${cat < $log-fifo}.log($level, $path);
        $log-fifo.remove;
    }).cleanup;
    $log-fifo;
}

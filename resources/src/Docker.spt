class Docker { }
class DockerImg { }

constant File $*docker-socket = '/var/run/docker.sock';
constant File $*docker-install-cli-path = '/usr/local/bin/docker';

constant Cmd $*docker = on {
    Spit-Helper { 'docker' }
    Linux {
        Cmd<docker> or (
            if $*docker-socket {
                debug "$_ exists so only installing docker cli";
                Docker.install-cli;
            } else {
                debug "$_ doesn't exist so installing the full Docker package";
                Docker.install;
                'docker';
            }
        )
    }
}

constant $*moby-github = GitHubRepo<moby/moby>;

constant File $?docker-cleanup = ${mktemp};

augment Docker {

    static method latest-build-ver~ {
        my $gh-release-url = $*moby-github.latest-release-url;
        die "unable to get latest docker version" unless $gh-release-url;
        $gh-release-url.${sed 's/.*\/v//'};
    }

    static method latest-build-tgz-url-->HTTP {
        my $latest-v = Docker.latest-build-ver;
        "https://get.docker.com/builds/Linux/x86_64/docker-{$latest-v}.tgz";
    }
    static method install-cli-->File {
        my $url = Docker.latest-build-tgz-url;
        info "Getting latest docker build from $url";
        my $docker-dir = $url.get.extract.cleanup;
        info "Installing to $*docker-install-cli-path";
        $docker-dir.add('docker').move-to($*docker-install-cli-path);
        $*docker-install-cli-path;
    }

    static method install {
        info 'running https://get.docker.com script';
        ${
            sh -c (HTTP<https://get.docker.com>.get)
            >debug('docker-install.sh')
            !>debug('docker-install.sh')
        };
    }

    static method hello-world? {
        ${ $*docker run -i --rm hello-world >debug('üê≥:hell-world') !>debug('üê≥:hello-world') };
    }

    method cleanup -->Docker {
        $?docker-cleanup.push($self);
        END {
            $?docker-cleanup.slurp-->List[Docker].remove;
            $?docker-cleanup.remove;
        }
    }

    static method create(
        $from,
        :$name,
        :@args,
        Bool :$mount-socket
    ) -->Docker {
        my $id = ${
            $*docker create -i !>error('üê≥-create')
            ("--name=$_" if $name)
            ("-v=$*docker-socket:$*docker-socket" if $mount-socket)
            @args $from sh -c ':;sh'
        }.substr(0,12); # 12 is a sufficient length of hash
        $name || $id;
    }

    method exists? ${ $*docker container inspect $self *>X }
    method Bool    { $self.exists }

    method copy($from,$to) {
        ${ $*docker cp $from "$self:$to" !>error('üê≥-copy')}
    }

    method remove? { $self-->List[Docker].remove }

    method running? {
        ${ $*docker inspect -f '{{.State.Status}}' $self } eq 'running';
    }

    method start-sleep {
        debug "Starting docker container $self with sleep";
        'while true; do sleep 1; done'.${ $*docker start $self };
    }

    method exec(Str $eval)? {
        if $self.running {
            $eval.${ $*docker exec -i $self sh >debug("üê≥:$self") !>warn("üê≥:$self")};
        } else {
            $eval.${
                $*docker start >debug("üê≥:$self") !>warn("üê≥:$self") -i $self
            };
        }
    }

    method commit(
        $name,
        :$tag,
        :$cmd,
        :$env,
        :$entrypoint,
        :$expose,
        :$label,
        :$onbuild,
        :$user,
        :$volume,
        :$workdir
    )-->DockerImg {
        my DockerImg $img-name = $name ~ (":$_" if $tag);
        info "Committing $self as $img-name";
        ${$*docker commit >X !>fatal('üê≥-commit')
          ("-c=CMD $_" if $cmd )
          ("-c=ENV $_" if $env )
          ("-c=ENTRYPOINT $_" if $entrypoint)
          ("-c=EXPOSE $_" if $expose)
          ("-c=USER $_" if $user)
          ("-c=VOLUME $_" if $volume)
          ("-c=WORKDIR $_" if $workdir)
          $self
          $img-name
         } ?? $img-name !! ();
    }
}

augment DockerImg {
    method exists? { ${ $*docker image inspect $self *>X } }
    method remove? { $self-->List[DockerImg].remove }
    method Bool { $self.exists }
    method add-tag ($tag)^ {
        my $tagged-name = "{$self.name}:$tag";
        info "Tagging $self with $tagged-name";
        ${$*docker tag $self $tagged-name !>fatal('üê≥-tag')} ?? $tagged-name !! ()
    }

    method alias-tag(DockerImg $name)^ {
        info "Tagging $self with $name";
        ${$*docker tag $self $name !>fatal('üê≥-tag')} ?? $name !! ()
    }

    method name~ {
        $self.${sed -r 's/(.*):.*/\1/'}
    }

    method tag~ {
        $self.${sed 's/.*://;t;s/.*/latest/' }
    }

    static method list -->List[DockerImg] {
        ${$*docker images | sed -n '1!p' |
          awk '{ if($1 == "<none>"){ print $3 } else { print $1($2 == "<none>" ? "" : ":"$2) }}'
         }
    }
}

augment List[Docker] {
    method remove? {
        debug "Removing containers: {$self.join(',')}";
        ${ $*docker rm -f @$self >X}
    }
}

augment List[DockerImg] {
    method remove? {
        debug "Removing images: {$self.join(',')}";
        ${ $*docker rmi @$self >debug('üê≥-rmi') !>warn('üê≥-rmi') }
    }
}
